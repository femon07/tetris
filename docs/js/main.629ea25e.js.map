{"version":3,"file":"js/main.629ea25e.js","mappings":"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","sources":["webpack://tetris/./src/game/Tetris.js","webpack://tetris/./src/game/Tetromino.js","webpack://tetris/./src/utils/helpers.js","webpack://tetris/./src/game/Board.js","webpack://tetris/./src/constants/game.js","webpack://tetris/./src/index.js","webpack://tetris/./src/game/GameState.js"],"sourcesContent":["import { COLS, ROWS, GAME_STATE, KEY, LEVEL_SPEED, LINES_PER_LEVEL } from '../constants/game';\nimport { calculateScore, calculateLevel, isMobileDevice } from '../utils/helpers';\nimport Board from './Board';\nimport Tetromino from './Tetromino';\nimport GameState from './GameState';\n\n/**\n * テトリスゲームのメインクラス\n */\nclass Tetris {\n  /**\n   * 新しいゲームインスタンスを作成する\n   * @param {Object} options - ゲームオプション\n   * @param {HTMLElement} options.canvas - ゲームを描画するCanvas要素\n   * @param {Function} options.onUpdate - ゲーム状態が更新されたときに呼ばれるコールバック\n   * @param {Function} options.onGameOver - ゲームオーバー時に呼ばれるコールバック\n   */\n  constructor({ canvas, onUpdate = () => {}, onGameOver = () => {} }) {\n    if (!canvas) {\n      throw new Error('Canvas element is required');\n    }\n\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d');\n    this.onUpdate = onUpdate;\n    this.onGameOver = onGameOver;\n    \n    // ゲームの状態管理\n    this.state = new GameState();\n    this.board = new Board(COLS, ROWS);\n    this.currentPiece = null;\n    this.nextPiece = null;\n    this.ghostPiece = null;\n    this.isPressingDown = false;\n    this.dropStart = 0;\n    this.lastDropTime = 0;\n    this.lastMoveTime = 0;\n    this.moveDelay = 100; // 左右移動の遅延（ミリ秒）\n    this.autoRepeatDelay = 100; // 自動繰り返しの遅延（ミリ秒）\n    this.lastMoveDirection = null;\n    this.isAutoRepeating = false;\n    this.animationFrameId = null;\n    \n    // キャンバスのサイズを設定\n    this.setCanvasSize();\n    \n    // イベントリスナーを設定\n    this.setupEventListeners();\n    \n    // ゲームを初期化\n    this.init();\n  }\n\n  /**\n   * ゲームを初期化する\n   */\n  init() {\n    this.board.reset();\n    this.state.reset();\n    this.spawnPiece();\n    this.update();\n    this.notifyUpdate();\n  }\n\n  /**\n   * キャンバスのサイズを設定する\n   */\n  setCanvasSize() {\n    // 1ブロックのサイズを計算（キャンバスの幅に基づく）\n    const blockSize = Math.floor(this.canvas.offsetWidth / COLS);\n    this.blockSize = blockSize;\n    \n    // キャンバスの表示サイズを設定\n    this.canvas.width = COLS * blockSize;\n    this.canvas.height = ROWS * blockSize;\n    \n    // キャンバスのスタイルを設定\n    this.canvas.style.width = `${COLS * blockSize}px`;\n    this.canvas.style.height = `${ROWS * blockSize}px`;\n    \n    // 高解像度ディスプレイ用にスケーリングを設定\n    const dpr = window.devicePixelRatio || 1;\n    this.canvas.width = COLS * blockSize * dpr;\n    this.canvas.height = ROWS * blockSize * dpr;\n    this.ctx.scale(dpr, dpr);\n  }\n\n  /**\n   * 新しいテトリミノを生成する\n   */\n  spawnPiece() {\n    // 現在のピースを次のピースに設定（または新しいピースを生成）\n    this.currentPiece = this.nextPiece || new Tetromino();\n    \n    // 次のピースを生成\n    this.nextPiece = new Tetromino();\n    \n    // 初期位置を設定（上部中央）\n    this.currentPiece.setPosition({\n      x: Math.floor((COLS - this.currentPiece.width) / 2),\n      y: 0\n    });\n    \n    // ゴーストピースを更新\n    this.updateGhostPiece();\n    \n    // ゲームオーバーチェック\n    if (this.checkCollision(this.currentPiece)) {\n      this.gameOver();\n    }\n  }\n\n  /**\n   * ゴーストピースを更新する\n   */\n  updateGhostPiece() {\n    if (!this.currentPiece) return;\n    \n    // 現在のピースをコピーしてゴーストピースを作成\n    this.ghostPiece = this.currentPiece.clone();\n    \n    // ゴーストピースを最下部まで落とす\n    while (!this.checkCollision(this.ghostPiece, { x: 0, y: 1 })) {\n      this.ghostPiece.move({ y: 1 });\n    }\n  }\n\n  /**\n   * 衝突判定を行う\n   * @param {Tetromino} piece - チェックするテトリミノ\n   * @param {Object} offset - オフセット {x, y}\n   * @return {boolean} 衝突する場合はtrue\n   */\n  checkCollision(piece, offset = { x: 0, y: 0 }) {\n    const testPiece = piece.clone();\n    testPiece.move(offset);\n    return !this.board.isValidPosition(testPiece);\n  }\n\n  /**\n   * ゲームのメインループ\n   * @param {number} timestamp - 現在のタイムスタンプ\n   */\n  update(timestamp = 0) {\n    const state = this.state.getState();\n    \n    // ゲームがプレイ中でない場合は何もしない\n    if (state.state !== GAME_STATE.PLAYING) {\n      this.animationFrameId = requestAnimationFrame((ts) => this.update(ts));\n      return;\n    }\n    \n    // 経過時間を計算\n    const deltaTime = timestamp - this.lastDropTime;\n    const dropInterval = this.getDropInterval();\n    \n    // 自動落下処理\n    if (deltaTime > dropInterval || this.isPressingDown) {\n      this.moveDown();\n      this.lastDropTime = timestamp;\n    }\n    \n    // 描画を更新\n    this.draw();\n    \n    // 次のフレームをリクエスト\n    this.animationFrameId = requestAnimationFrame((ts) => this.update(ts));\n  }\n\n  /**\n   * 現在のレベルに基づいて落下間隔を取得する\n   * @return {number} 落下間隔（ミリ秒）\n   */\n  getDropInterval() {\n    const level = this.state.getState().level;\n    const speed = LEVEL_SPEED[Math.min(level, Object.keys(LEVEL_SPEED).length)];\n    return this.isPressingDown ? Math.max(50, speed / 10) : speed; // 高速落下時はより速く\n  }\n\n  /**\n   * ゲームの描画を更新する\n   */\n  draw() {\n    // キャンバスをクリア\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    // ゲームボードを描画\n    this.drawBoard();\n    \n    // ゴーストピースを描画\n    if (this.ghostPiece) {\n      this.drawPiece(this.ghostPiece, 0.3);\n    }\n    \n    // 現在のピースを描画\n    if (this.currentPiece) {\n      this.drawPiece(this.currentPiece);\n    }\n    \n    // グリッドを描画\n    this.drawGrid();\n  }\n\n  /**\n   * ゲームボードを描画する\n   */\n  drawBoard() {\n    const { grid } = this.board;\n    \n    for (let y = 0; y < grid.length; y++) {\n      for (let x = 0; x < grid[y].length; x++) {\n        if (grid[y][x]) {\n          this.drawBlock(x, y, grid[y][x]);\n        }\n      }\n    }\n  }\n\n  /**\n   * テトリミノを描画する\n   * @param {Tetromino} piece - 描画するテトリミノ\n   * @param {number} alpha - 透明度（0-1）\n   */\n  drawPiece(piece, alpha = 1.0) {\n    const blocks = piece.getBlocks();\n    \n    blocks.forEach(block => {\n      if (block.y >= 0) { // ボードの上からはみ出している部分は描画しない\n        this.drawBlock(block.x, block.y, block.color, alpha);\n      }\n    });\n  }\n\n  /**\n   * ブロックを描画する\n   * @param {number} x - X座標\n   * @param {number} y - Y座標\n   * @param {string} color - 色\n   * @param {number} alpha - 透明度（0-1）\n   */\n  drawBlock(x, y, color, alpha = 1.0) {\n    const size = this.blockSize;\n    const padding = 1;\n    const blockSize = size - padding * 2;\n    \n    // ブロックの背景\n    this.ctx.fillStyle = color;\n    this.ctx.globalAlpha = alpha;\n    this.ctx.fillRect(\n      x * size + padding,\n      y * size + padding,\n      blockSize,\n      blockSize\n    );\n    \n    // ハイライト（左上）\n    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';\n    this.ctx.fillRect(\n      x * size + padding,\n      y * size + padding,\n      blockSize * 0.7,\n      blockSize * 0.2\n    );\n    this.ctx.fillRect(\n      x * size + padding,\n      y * size + padding,\n      blockSize * 0.2,\n      blockSize * 0.7\n    );\n    \n    // シャドウ（右下）\n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\n    this.ctx.fillRect(\n      x * size + padding + blockSize * 0.3,\n      y * size + padding + blockSize * 0.8,\n      blockSize * 0.7,\n      blockSize * 0.2\n    );\n    this.ctx.fillRect(\n      x * size + padding + blockSize * 0.8,\n      y * size + padding + blockSize * 0.3,\n      blockSize * 0.2,\n      blockSize * 0.7\n    );\n    \n    this.ctx.globalAlpha = 1.0;\n  }\n\n  /**\n   * グリッドを描画する\n   */\n  drawGrid() {\n    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';\n    this.ctx.lineWidth = 0.5;\n    \n    // 縦線\n    for (let x = 0; x <= COLS; x++) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(x * this.blockSize, 0);\n      this.ctx.lineTo(x * this.blockSize, ROWS * this.blockSize);\n      this.ctx.stroke();\n    }\n    \n    // 横線\n    for (let y = 0; y <= ROWS; y++) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(0, y * this.blockSize);\n      this.ctx.lineTo(COLS * this.blockSize, y * this.blockSize);\n      this.ctx.stroke();\n    }\n  }\n\n  /**\n   * テトリミノを左に移動する\n   */\n  moveLeft() {\n    if (!this.checkCollision(this.currentPiece, { x: -1, y: 0 })) {\n      this.currentPiece.move({ x: -1 });\n      this.updateGhostPiece();\n      this.lastMoveTime = performance.now();\n      this.lastMoveDirection = 'left';\n      this.notifyUpdate();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * テトリミノを右に移動する\n   */\n  moveRight() {\n    if (!this.checkCollision(this.currentPiece, { x: 1, y: 0 })) {\n      this.currentPiece.move({ x: 1 });\n      this.updateGhostPiece();\n      this.lastMoveTime = performance.now();\n      this.lastMoveDirection = 'right';\n      this.notifyUpdate();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * テトリミノを下に移動する\n   * @return {boolean} 移動に成功したかどうか\n   */\n  moveDown() {\n    if (!this.checkCollision(this.currentPiece, { x: 0, y: 1 })) {\n      this.currentPiece.move({ y: 1 });\n      this.updateGhostPiece();\n      this.notifyUpdate();\n      return true;\n    } else {\n      this.lockPiece();\n      return false;\n    }\n  }\n\n  /**\n   * テトリミノを回転させる\n   */\n  rotate() {\n    const originalRotation = this.currentPiece.rotation;\n    this.currentPiece.rotate();\n    \n    // 回転後の位置が有効でない場合は、壁蹴り（Wall Kick）を試みる\n    if (this.checkCollision(this.currentPiece)) {\n      // 左右にずらして再試行\n      const kicks = [1, -1, 2, -2];\n      for (const kick of kicks) {\n        if (!this.checkCollision(this.currentPiece, { x: kick, y: 0 })) {\n          this.currentPiece.move({ x: kick });\n          this.updateGhostPiece();\n          this.notifyUpdate();\n          return true;\n        }\n      }\n      \n      // どの位置でも回転できない場合は元に戻す\n      while (this.currentPiece.rotation !== originalRotation) {\n        this.currentPiece.rotateCounterClockwise();\n      }\n      return false;\n    }\n    \n    this.updateGhostPiece();\n    this.notifyUpdate();\n    return true;\n  }\n\n  /**\n   * テトリミノを最下部まで落とす（ハードドロップ）\n   */\n  hardDrop() {\n    let dropDistance = 0;\n    \n    while (!this.checkCollision(this.currentPiece, { x: 0, y: dropDistance + 1 })) {\n      dropDistance++;\n    }\n    \n    if (dropDistance > 0) {\n      this.currentPiece.move({ y: dropDistance });\n      this.lockPiece();\n      return true;\n    }\n    \n    return false;\n  }\n\n  /**\n   * 現在のテトリミノを固定する\n   */\n  lockPiece() {\n    const linesCleared = this.board.lock(this.currentPiece);\n    \n    if (linesCleared > 0) {\n      // スコアを加算\n      this.state.addScore(linesCleared);\n      \n      // レベルアップのチェック\n      const newLevel = calculateLevel(this.state.getState().lines, LINES_PER_LEVEL);\n      if (newLevel > this.state.getState().level) {\n        // レベルアップ時の処理\n      }\n    }\n    \n    // 新しいピースを生成\n    this.spawnPiece();\n    this.notifyUpdate();\n  }\n\n  /**\n   * ゲームを開始する\n   */\n  start() {\n    if (this.state.start()) {\n      this.lastDropTime = performance.now();\n      this.update();\n      this.notifyUpdate();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * ゲームを一時停止/再開する\n   */\n  pause() {\n    return this.state.pause();\n  }\n\n  /**\n   * ゲームオーバーにする\n   */\n  gameOver() {\n    if (this.state.gameOver()) {\n      this.onGameOver(this.state.getState());\n      this.notifyUpdate();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * ゲームをリセットする\n   */\n  reset() {\n    cancelAnimationFrame(this.animationFrameId);\n    this.board.reset();\n    this.state.reset();\n    this.spawnPiece();\n    this.lastDropTime = performance.now();\n    this.update();\n    this.notifyUpdate();\n  }\n\n  /**\n   * ゲームの状態が更新されたことを通知する\n   */\n  notifyUpdate() {\n    if (typeof this.onUpdate === 'function') {\n      this.onUpdate({\n        ...this.state.getState(),\n        nextPiece: this.nextPiece,\n        board: this.board.getState(),\n      });\n    }\n  }\n\n  /**\n   * イベントリスナーを設定する\n   */\n  setupEventListeners() {\n    // キーボードイベント\n    document.addEventListener('keydown', this.handleKeyDown.bind(this));\n    document.addEventListener('keyup', this.handleKeyUp.bind(this));\n    \n    // タッチイベント（モバイル対応）\n    if (isMobileDevice()) {\n      this.setupTouchControls();\n    }\n    \n    // ウィンドウのリサイズイベント\n    window.addEventListener('resize', this.handleResize.bind(this));\n  }\n\n  /**\n   * キーダウンイベントを処理する\n   * @param {KeyboardEvent} event - キーボードイベント\n   */\n  handleKeyDown(event) {\n    if (this.state.getState().state !== GAME_STATE.PLAYING) {\n      return;\n    }\n    \n    switch (event.key) {\n      case KEY.LEFT:\n        if (!this.isAutoRepeating) {\n          this.moveLeft();\n          this.isAutoRepeating = true;\n          this.autoRepeatTimeout = setTimeout(() => {\n            this.autoRepeatInterval = setInterval(() => this.moveLeft(), this.autoRepeatDelay);\n          }, this.moveDelay);\n        }\n        break;\n        \n      case KEY.RIGHT:\n        if (!this.isAutoRepeating) {\n          this.moveRight();\n          this.isAutoRepeating = true;\n          this.autoRepeatTimeout = setTimeout(() => {\n            this.autoRepeatInterval = setInterval(() => this.moveRight(), this.autoRepeatDelay);\n          }, this.moveDelay);\n        }\n        break;\n        \n      case KEY.DOWN:\n        this.isPressingDown = true;\n        break;\n        \n      case KEY.UP:\n        this.rotate();\n        break;\n        \n      case ' ':\n        this.hardDrop();\n        break;\n        \n      case 'p':\n      case 'P':\n        this.pause();\n        break;\n        \n      case 'r':\n      case 'R':\n        this.reset();\n        break;\n    }\n    \n    // デフォルトのキーアクションを防ぐ\n    if ([KEY.LEFT, KEY.RIGHT, KEY.DOWN, KEY.UP, ' ', 'p', 'P', 'r', 'R'].includes(event.key)) {\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * キーアップイベントを処理する\n   * @param {KeyboardEvent} event - キーボードイベント\n   */\n  handleKeyUp(event) {\n    switch (event.key) {\n      case KEY.LEFT:\n      case KEY.RIGHT:\n        clearTimeout(this.autoRepeatTimeout);\n        clearInterval(this.autoRepeatInterval);\n        this.isAutoRepeating = false;\n        break;\n        \n      case KEY.DOWN:\n        this.isPressingDown = false;\n        break;\n    }\n  }\n\n  /**\n   * タッチコントロールを設定する\n   */\n  setupTouchControls() {\n    let touchStartX = 0;\n    let touchStartY = 0;\n    let touchStartTime = 0;\n    \n    this.canvas.addEventListener('touchstart', (e) => {\n      if (this.state.getState().state !== GAME_STATE.PLAYING) return;\n      \n      const touch = e.touches[0];\n      touchStartX = touch.clientX;\n      touchStartY = touch.clientY;\n      touchStartTime = Date.now();\n      \n      // 長押し検出用\n      this.longPressTimer = setTimeout(() => {\n        this.isPressingDown = true;\n      }, 300);\n      \n      e.preventDefault();\n    }, { passive: false });\n    \n    this.canvas.addEventListener('touchmove', (e) => {\n      e.preventDefault();\n    }, { passive: false });\n    \n    this.canvas.addEventListener('touchend', (e) => {\n      if (this.state.getState().state !== GAME_STATE.PLAYING) return;\n      \n      clearTimeout(this.longPressTimer);\n      this.isPressingDown = false;\n      \n      const touch = e.changedTouches[0];\n      const deltaX = touch.clientX - touchStartX;\n      const deltaY = touch.clientY - touchStartY;\n      const deltaTime = Date.now() - touchStartTime;\n      \n      // スワイプ検出\n      if (deltaTime < 300) { // 300ms以内のタッチのみ\n        if (Math.abs(deltaX) > Math.abs(deltaY)) {\n          // 横スワイプ\n          if (deltaX > 30) {\n            this.moveRight();\n          } else if (deltaX < -30) {\n            this.moveLeft();\n          }\n        } else {\n          // 縦スワイプ\n          if (deltaY > 30) {\n            this.hardDrop();\n          } else if (deltaY < -30) {\n            this.rotate();\n          } else {\n            // タップの場合は回転\n            this.rotate();\n          }\n        }\n      }\n      \n      e.preventDefault();\n    }, { passive: false });\n  }\n\n  /**\n   * ウィンドウのリサイズを処理する\n   */\n  handleResize() {\n    this.setCanvasSize();\n    this.draw();\n  }\n\n  /**\n   * ゲームを破棄する（クリーンアップ）\n   */\n  destroy() {\n    // イベントリスナーを削除\n    document.removeEventListener('keydown', this.handleKeyDown);\n    document.removeEventListener('keyup', this.handleKeyUp);\n    window.removeEventListener('resize', this.handleResize);\n    \n    // アニメーションフレームをキャンセル\n    cancelAnimationFrame(this.animationFrameId);\n    \n    // タイマーをクリア\n    clearTimeout(this.autoRepeatTimeout);\n    clearInterval(this.autoRepeatInterval);\n    clearTimeout(this.longPressTimer);\n    \n    // キャンバスをクリア\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n}\n\nexport default Tetris;\n","import { TETROMINOS, COLORS } from '../constants/game';\nimport { deepCopyMatrix, rotateMatrix } from '../utils/helpers';\n\n/**\n * テトリミノ（テトロミノ）を管理するクラス\n */\nclass Tetromino {\n  /**\n   * 新しいテトリミノを作成する\n   * @param {number} type - テトリミノのタイプ（0-6）\n   * @param {Object} position - 初期位置 {x, y}\n   */\n  constructor(type = null, position = { x: 0, y: 0 }) {\n    this.type = type !== null ? type : Math.floor(Math.random() * TETROMINOS.length);\n    this.matrix = deepCopyMatrix(TETROMINOS[this.type]);\n    this.position = { ...position };\n    this.color = COLORS[this.type + 1]; // +1 because 0 is empty\n    this.rotation = 0; // 0-3 (0°, 90°, 180°, 270°)\n  }\n\n  /**\n   * テトリミノを時計回りに回転させる\n   * @return {Array} 回転後のマトリックス\n   */\n  rotate() {\n    this.matrix = rotateMatrix(this.matrix);\n    this.rotation = (this.rotation + 1) % 4;\n    return this.matrix;\n  }\n\n  /**\n   * テトリミノを反時計回りに回転させる\n   * @return {Array} 回転後のマトリックス\n   */\n  rotateCounterClockwise() {\n    // 反時計回りに3回回転 = 時計回りに1回回転と等価\n    for (let i = 0; i < 3; i++) {\n      this.matrix = rotateMatrix(this.matrix);\n    }\n    this.rotation = (this.rotation + 3) % 4;\n    return this.matrix;\n  }\n\n  /**\n   * テトリミノを移動させる\n   * @param {Object} delta - 移動量 {x, y}\n   */\n  move(delta) {\n    this.position.x += delta.x || 0;\n    this.position.y += delta.y || 0;\n  }\n\n  /**\n   * テトリミノの位置を設定する\n   * @param {Object} position - 新しい位置 {x, y}\n   */\n  setPosition(position) {\n    if (position.x !== undefined) this.position.x = position.x;\n    if (position.y !== undefined) this.position.y = position.y;\n  }\n\n  /**\n   * テトリミノの各ブロックの位置を取得する\n   * @return {Array} 各ブロックの位置の配列 [{x, y}]\n   */\n  getBlocks() {\n    const blocks = [];\n    for (let y = 0; y < this.matrix.length; y++) {\n      for (let x = 0; x < this.matrix[y].length; x++) {\n        if (this.matrix[y][x]) {\n          blocks.push({\n            x: this.position.x + x,\n            y: this.position.y + y,\n            color: this.color,\n          });\n        }\n      }\n    }\n    return blocks;\n  }\n\n  /**\n   * テトリミノのコピーを作成する\n   * @return {Tetromino} 新しいテトリミノインスタンス\n   */\n  clone() {\n    const clone = new Tetromino(this.type, { ...this.position });\n    clone.matrix = deepCopyMatrix(this.matrix);\n    clone.rotation = this.rotation;\n    return clone;\n  }\n\n  /**\n   * テトリミノの幅を取得する\n   * @return {number} 幅（ブロック数）\n   */\n  get width() {\n    return this.matrix[0].length;\n  }\n\n  /**\n   * テトリミノの高さを取得する\n   * @return {number} 高さ（ブロック数）\n   */\n  get height() {\n    return this.matrix.length;\n  }\n\n  /**\n   * テトリミノの左端の位置を取得する\n   * @return {number} x座標\n   */\n  get left() {\n    return this.position.x;\n  }\n\n  /**\n   * テトリミノの右端の位置を取得する\n   * @return {number} x座標 + 幅\n   */\n  get right() {\n    return this.position.x + this.width;\n  }\n\n  /**\n   * テトリミノの上端の位置を取得する\n   * @return {number} y座標\n   */\n  get top() {\n    return this.position.y;\n  }\n\n  /**\n   * テトリミノの下端の位置を取得する\n   * @return {number} y座標 + 高さ\n   */\n  get bottom() {\n    return this.position.y + this.height;\n  }\n\n  /**\n   * ランダムなテトリミノを生成する\n   * @param {Object} position - 初期位置 {x, y}\n   * @return {Tetromino} 新しいテトリミノインスタンス\n   */\n  static createRandom(position = { x: 0, y: 0 }) {\n    const type = Math.floor(Math.random() * TETROMINOS.length);\n    return new Tetromino(type, position);\n  }\n}\n\nexport default Tetromino;\n","/**\n * 2次元配列をディープコピーする\n * @param {Array} matrix - コピーする2次元配列\n * @return {Array} ディープコピーされた新しい配列\n */\nexport const deepCopyMatrix = (matrix) => {\n  return matrix.map(row => [...row]);\n};\n\n/**\n * 2次元配列を転置する\n * @param {Array} matrix - 転置する2次元配列\n * @return {Array} 転置された新しい配列\n */\nexport const transposeMatrix = (matrix) => {\n  return matrix[0].map((_, i) => matrix.map(row => row[i]));\n};\n\n/**\n * 行列を時計回りに90度回転させる\n * @param {Array} matrix - 回転させる2次元配列\n * @return {Array} 回転された新しい配列\n */\nexport const rotateMatrix = (matrix) => {\n  const n = matrix.length;\n  const result = Array(n).fill().map(() => Array(n).fill(0));\n  \n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      result[j][n - 1 - i] = matrix[i][j];\n    }\n  }\n  \n  return result;\n};\n\n/**\n * 2つの位置が等しいかどうかを判定する\n * @param {Object} pos1 - 位置1 {x, y}\n * @param {Object} pos2 - 位置2 {x, y}\n * @return {boolean} 等しければtrue\n */\nexport const arePositionsEqual = (pos1, pos2) => {\n  return pos1.x === pos2.x && pos1.y === pos2.y;\n};\n\n/**\n * ランダムな整数を生成する\n * @param {number} min - 最小値（含む）\n * @param {number} max - 最大値（含む）\n * @return {number} 生成されたランダムな整数\n */\nexport const getRandomInt = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\n/**\n * ミリ秒を待機する\n * @param {number} ms - 待機するミリ秒\n * @return {Promise} 指定時間後に解決するPromise\n */\nexport const sleep = (ms) => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\n\n/**\n * スコアを計算する\n * @param {number} linesCleared - 消したライン数 (0-4)\n * @param {number} currentScore - 現在のスコア\n * @return {number} 新しいスコア\n */\nexport const calculateScore = (linesCleared, currentScore = 0) => {\n  if (linesCleared === 0) return currentScore;\n  \n  // テトリス公式のスコア計算に基づく\n  const linePoints = [0, 40, 100, 300, 1200];\n  const level = Math.floor(currentScore / 1000) + 1;\n  \n  return currentScore + (linePoints[linesCleared] || 0) * level;\n};\n\n/**\n * レベルを計算する\n * @param {number} lines - 消したラインの合計\n * @param {number} linesPerLevel - レベルアップに必要なライン数\n * @return {number} 現在のレベル\n */\nexport const calculateLevel = (lines, linesPerLevel = 10) => {\n  return Math.floor(lines / linesPerLevel) + 1;\n};\n\n/**\n * ゲームスピードを計算する\n * @param {number} level - 現在のレベル\n * @param {Object} speedTable - レベルごとのスピードテーブル\n * @return {number} ミリ秒単位のスピード\n */\nexport const calculateGameSpeed = (level, speedTable) => {\n  return speedTable[Math.min(level, Object.keys(speedTable).length)] || speedTable[Object.keys(speedTable).length];\n};\n\n/**\n * モバイルデバイスかどうかを判定する\n * @return {boolean} モバイルデバイスの場合はtrue\n */\nexport const isMobileDevice = () => {\n  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n};\n\n/**\n * タッチイベントを処理する\n * @param {Event} e - タッチイベント\n * @return {Object} 正規化された位置 {x, y}\n */\nexport const getTouchPosition = (e) => {\n  if (!e.touches) return null;\n  const touch = e.touches[0] || e.changedTouches[0];\n  const rect = e.target.getBoundingClientRect();\n  \n  return {\n    x: touch.clientX - rect.left,\n    y: touch.clientY - rect.top,\n  };\n};\n","import { COLS, ROWS } from '../constants/game';\nimport { deepCopyMatrix } from '../utils/helpers';\n\n/**\n * テトリスゲームのボードを管理するクラス\n */\nclass Board {\n  /**\n   * 新しいボードを作成する\n   * @param {number} cols - ボードの幅（列数）\n   * @param {number} rows - ボードの高さ（行数）\n   */\n  constructor(cols = COLS, rows = ROWS) {\n    this.cols = cols;\n    this.rows = rows;\n    this.grid = this.createEmptyGrid();\n    this.clearedLines = 0;\n  }\n\n  /**\n   * 空のグリッドを作成する\n   * @return {Array} 空の2次元配列\n   */\n  createEmptyGrid() {\n    return Array(this.rows).fill().map(() => Array(this.cols).fill(0));\n  }\n\n  /**\n   * ボードをリセットする\n   */\n  reset() {\n    this.grid = this.createEmptyGrid();\n    this.clearedLines = 0;\n  }\n\n  /**\n   * テトリミノがボード内で有効な位置にあるかどうかをチェックする\n   * @param {Tetromino} tetromino - チェックするテトリミノ\n   * @return {boolean} 有効な位置の場合はtrue\n   */\n  isValidPosition(tetromino) {\n    const matrix = tetromino.matrix;\n    const pos = tetromino.position;\n\n    for (let y = 0; y < matrix.length; y++) {\n      for (let x = 0; x < matrix[y].length; x++) {\n        if (matrix[y][x] !== 0) {\n          const boardX = pos.x + x;\n          const boardY = pos.y + y;\n\n          // ボードの外側にあるかチェック\n          if (\n            boardX < 0 ||\n            boardX >= this.cols ||\n            boardY < 0 ||\n            boardY >= this.rows\n          ) {\n            return false;\n          }\n\n          // 既存のブロックと重なっていないかチェック\n          if (boardY >= 0 && this.grid[boardY][boardX] !== 0) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * テトリミノをボードに固定する\n   * @param {Tetromino} tetromino - 固定するテトリミノ\n   * @return {number} 消去したライン数\n   */\n  lock(tetromino) {\n    const blocks = tetromino.getBlocks();\n    \n    // テトリミノのブロックをボードに配置\n    blocks.forEach(block => {\n      if (block.y >= 0) { // ボードの上からはみ出している部分は無視\n        this.grid[block.y][block.x] = block.color;\n      }\n    });\n\n    // ラインの消去処理\n    return this.clearLines();\n  }\n\n  /**\n   * 揃ったラインを消去する\n   * @return {number} 消去したライン数\n   */\n  clearLines() {\n    let linesCleared = 0;\n    \n    // 下から上にチェック\n    for (let y = this.rows - 1; y >= 0; y--) {\n      // ラインが揃っているかチェック\n      if (this.isLineComplete(y)) {\n        // ラインを消去して上にずらす\n        this.removeLine(y);\n        linesCleared++;\n        // 同じ行を再度チェックする（1つ下の行が上にずれるため）\n        y++;\n      }\n    }\n\n    \n    this.clearedLines += linesCleared;\n    return linesCleared;\n  }\n\n  /**\n   * 指定された行が揃っているかどうかをチェックする\n   * @param {number} row - チェックする行\n   * @return {boolean} 行が揃っている場合はtrue\n   */\n  isLineComplete(row) {\n    for (let x = 0; x < this.cols; x++) {\n      if (this.grid[row][x] === 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * 指定された行を削除し、上の行を下にずらす\n   * @param {number} row - 削除する行\n   */\n  removeLine(row) {\n    // 指定された行を削除\n    this.grid.splice(row, 1);\n    // 上部に新しい空の行を追加\n    this.grid.unshift(Array(this.cols).fill(0));\n  }\n\n  /**\n   * ボードのコピーを取得する\n   * @return {Board} ボードのコピー\n   */\n  clone() {\n    const clone = new Board(this.cols, this.rows);\n    clone.grid = deepCopyMatrix(this.grid);\n    clone.clearedLines = this.clearedLines;\n    return clone;\n  }\n\n  /**\n   * ボードの状態を取得する\n   * @return {Object} ボードの状態\n   */\n  getState() {\n    return {\n      grid: deepCopyMatrix(this.grid),\n      clearedLines: this.clearedLines,\n      width: this.cols,\n      height: this.rows,\n    };\n  }\n\n  /**\n   * ボードをクリアする（デバッグ用）\n   */\n  clear() {\n    this.grid = this.createEmptyGrid();\n    this.clearedLines = 0;\n  }\n\n  /**\n   * デバッグ用にボードをコンソールに出力する\n   */\n  print() {\n    console.log('--- BOARD ---');\n    for (let y = 0; y < this.rows; y++) {\n      let line = '';\n      for (let x = 0; x < this.cols; x++) {\n        line += this.grid[y][x] ? '■' : '·';\n      }\n      console.log(line);\n    }\n    console.log('-------------');\n  }\n}\n\nexport default Board;\n","// ゲームの定数定義\nexport const COLS = 10;\nexport const ROWS = 20;\nexport const BLOCK_SIZE = 30;\n\nexport const COLORS = [\n  '#000000', // 空きマス\n  '#00FFFF', // I\n  '#FF00FF', // T\n  '#00FF00', // S\n  '#FFFF00', // O\n  '#FF0000', // Z\n  '#0000FF', // J\n  '#FFA500', // L\n];\n\nexport const TETROMINOS = [\n  // I\n  [\n    [0, 0, 0, 0],\n    [1, 1, 1, 1],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n  ],\n  // O\n  [\n    [4, 4],\n    [4, 4],\n  ],\n  // T\n  [\n    [0, 2, 0],\n    [2, 2, 2],\n    [0, 0, 0],\n  ],\n  // S\n  [\n    [0, 3, 3],\n    [3, 3, 0],\n    [0, 0, 0],\n  ],\n  // Z\n  [\n    [5, 5, 0],\n    [0, 5, 5],\n    [0, 0, 0],\n  ],\n  // J\n  [\n    [6, 0, 0],\n    [6, 6, 6],\n    [0, 0, 0],\n  ],\n  // L\n  [\n    [0, 0, 7],\n    [7, 7, 7],\n    [0, 0, 0],\n  ],\n];\n\nexport const LEVEL_SPEED = {\n  1: 1000, // 1秒\n  2: 900,\n  3: 800,\n  4: 700,\n  5: 600,\n  6: 500,\n  7: 400,\n  8: 300,\n  9: 200,\n  10: 100,\n  11: 80,\n  12: 60,\n  13: 40,\n  14: 30,\n  15: 20,\n  16: 10,\n  17: 5,\n  18: 4,\n  19: 3,\n  20: 2,\n  // レベル20以降は同じ速度\n  21: 1,\n};\n\nexport const LINES_PER_LEVEL = 10;\n\nexport const SCORE_TABLE = {\n  1: 100,   // 1行消し\n  2: 300,   // 2行同時消し\n  3: 500,   // 3行同時消し\n  4: 800,   // 4行同時消し（テトリス）\n};\n\nexport const KEY = {\n  LEFT: 'ArrowLeft',\n  RIGHT: 'ArrowRight',\n  DOWN: 'ArrowDown',\n  UP: 'ArrowUp',\n  SPACE: ' ',\n  P: 'p',\n  R: 'r',\n};\n\nexport const GAME_STATE = {\n  READY: 'ready',\n  PLAYING: 'playing',\n  PAUSED: 'paused',\n  GAME_OVER: 'gameOver',\n};\n","import Tetris from './game/Tetris';\nimport { isMobileDevice } from './utils/helpers';\nimport './styles.css';\n\n// ゲームの状態管理\nlet game = null;\nconst canvas = document.getElementById('game');\nconst startButton = document.getElementById('start-button');\nconst pauseButton = document.getElementById('pause-button');\nconst restartButton = document.getElementById('restart-button');\nconst scoreElement = document.getElementById('score');\nconst levelElement = document.getElementById('level');\nconst linesElement = document.getElementById('lines');\nconst highScoreElement = document.getElementById('high-score');\nconst nextPieceCanvas = document.getElementById('next-piece');\nconst nextPieceCtx = nextPieceCanvas?.getContext('2d');\nconst gameOverElement = document.getElementById('game-over');\n\n// ゲームの状態を更新するコールバック\nfunction onGameUpdate(state) {\n  if (!state) return;\n  \n  // スコアとレベルの更新\n  if (scoreElement) scoreElement.textContent = state.score || 0;\n  if (levelElement) levelElement.textContent = state.level || 1;\n  if (linesElement) linesElement.textContent = state.lines || 0;\n  \n  // ハイスコアを更新\n  const highScore = Math.max(\n    state.score || 0, \n    parseInt(localStorage.getItem('tetrisHighScore') || '0')\n  );\n  localStorage.setItem('tetrisHighScore', highScore.toString());\n  if (highScoreElement) highScoreElement.textContent = highScore;\n}\n\n// ゲームオーバー時のコールバック\nfunction onGameOver() {\n  console.log('Game Over');\n  if (gameOverElement) {\n    gameOverElement.style.display = 'flex';\n  }\n  if (restartButton) {\n    restartButton.disabled = false;\n  }\n}\n\n// ゲームを初期化する関数\nfunction initGame() {\n  // 既存のゲームがあれば破棄\n  if (game) {\n    game.destroy();\n  }\n  \n  // ゲームオーバー画面を非表示\n  if (gameOverElement) {\n    gameOverElement.style.display = 'none';\n  }\n  \n  // 新しいゲームインスタンスを作成\n  game = new Tetris({\n    canvas,\n    onUpdate: onGameUpdate,\n    onGameOver: onGameOver\n  });\n  \n  // ハイスコアを表示\n  const highScore = localStorage.getItem('tetrisHighScore') || '0';\n  if (highScoreElement) highScoreElement.textContent = highScore;\n  \n  // スコア表示をリセット\n  onGameUpdate({ score: 0, level: 1, lines: 0, state: 'playing' });\n  \n  // ゲームを開始\n  game.start();\n}\n\n// イベントリスナーを設定\nif (startButton) {\n  startButton.addEventListener('click', () => {\n    if (!game || game.state.getState().state === 'gameOver') {\n      initGame();\n    } else if (game.state.getState().state === 'paused') {\n      game.resume();\n      pauseButton.textContent = 'Pause';\n    } else {\n      game.pause();\n      pauseButton.textContent = 'Resume';\n    }\n  });\n}\n\nif (pauseButton) {\n  pauseButton.addEventListener('click', () => {\n    if (!game) return;\n    \n    const gameState = game.state.getState();\n    if (gameState.state === 'playing') {\n      game.pause();\n      pauseButton.textContent = 'Resume';\n    } else if (gameState.state === 'paused') {\n      game.resume();\n      pauseButton.textContent = 'Pause';\n    }\n  });\n}\n\nif (restartButton) {\n  restartButton.addEventListener('click', () => {\n    if (game) {\n      initGame();\n    }\n  });\n}\n\n// キーボードイベント\ndocument.addEventListener('keydown', (e) => {\n  if (!game) return;\n  \n  const gameState = game.state.getState();\n  \n  switch (e.key) {\n    case 'Escape':\n      if (gameState.state === 'playing') {\n        game.pause();\n        if (pauseButton) pauseButton.textContent = 'Resume';\n      } else if (gameState.state === 'paused') {\n        game.resume();\n        if (pauseButton) pauseButton.textContent = 'Pause';\n      }\n      break;\n      \n    case 'r':\n    case 'R':\n      if (gameState.state === 'gameOver') {\n        initGame();\n      }\n      break;\n      \n    case ' ':\n      if (gameState.state === 'playing') {\n        game.hardDrop();\n      }\n      break;\n      \n    default:\n      break;\n  }\n});\n\n// モバイルデバイスでのタッチイベントを無効化（スクロールを防ぐ）\ndocument.addEventListener('touchmove', (e) => {\n  if (isMobileDevice() && e.target === document.body) {\n    e.preventDefault();\n  }\n}, { passive: false });\n\n// ウィンドウのリサイズに応じてキャンバスのサイズを調整\nfunction resizeCanvas() {\n  if (!canvas) return;\n  \n  const container = canvas.parentElement;\n  if (!container) return;\n  \n  // キャンバスのアスペクト比を維持\n  const aspectRatio = 10 / 20; // 横10マス、縦20マス\n  let width = container.clientWidth - 40; // パディングを考慮\n  let height = width / aspectRatio;\n  \n  if (height > window.innerHeight - 100) {\n    height = window.innerHeight - 100;\n    width = height * aspectRatio;\n  }\n  \n  // キャンバスのサイズを設定\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n  \n  // ゲームが実行中の場合は再描画\n  if (game) {\n    game.render();\n  }\n}\n\n// ページ読み込み時にゲームを初期化\nwindow.addEventListener('load', () => {\n  // ハイスコアを表示\n  const highScore = localStorage.getItem('tetrisHighScore') || '0';\n  if (highScoreElement) highScoreElement.textContent = highScore;\n  \n  // キャンバスのサイズを調整\n  resizeCanvas();\n  \n  // ゲームを初期化\n  initGame();\n});\n\n// ウィンドウのリサイズ時にキャンバスのサイズを再調整\nwindow.addEventListener('resize', () => {\n  resizeCanvas();\n});\n","import { GAME_STATE } from '../constants/game';\n\n/**\n * ゲームの状態を管理するクラス\n */\nclass GameState {\n  constructor() {\n    this.state = GAME_STATE.READY;\n    this.score = 0;\n    this.lines = 0;\n    this.level = 1;\n    this.highScore = parseInt(localStorage.getItem('tetrisHighScore') || '0', 10);\n    this.startTime = null;\n    this.elapsedTime = 0;\n    this.lastUpdateTime = null;\n  }\n\n  /**\n   * ゲームを開始する\n   */\n  start() {\n    if (this.state === GAME_STATE.READY || this.state === GAME_STATE.GAME_OVER) {\n      this.state = GAME_STATE.PLAYING;\n      this.score = 0;\n      this.lines = 0;\n      this.level = 1;\n      this.startTime = Date.now();\n      this.lastUpdateTime = this.startTime;\n      this.elapsedTime = 0;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * ゲームをポーズする\n   */\n  pause() {\n    if (this.state === GAME_STATE.PLAYING) {\n      this.state = GAME_STATE.PAUSED;\n      this.updateElapsedTime();\n      return true;\n    } else if (this.state === GAME_STATE.PAUSED) {\n      this.state = GAME_STATE.PLAYING;\n      this.lastUpdateTime = Date.now();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * ゲームオーバーにする\n   */\n  gameOver() {\n    if (this.state === GAME_STATE.PLAYING) {\n      this.state = GAME_STATE.GAME_OVER;\n      this.updateElapsedTime();\n      this.updateHighScore();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * 経過時間を更新する\n   */\n  updateElapsedTime() {\n    if (this.state === GAME_STATE.PLAYING && this.lastUpdateTime) {\n      const now = Date.now();\n      this.elapsedTime += now - this.lastUpdateTime;\n      this.lastUpdateTime = now;\n    }\n  }\n\n  /**\n   * ハイスコアを更新する\n   */\n  updateHighScore() {\n    if (this.score > this.highScore) {\n      this.highScore = this.score;\n      localStorage.setItem('tetrisHighScore', this.highScore.toString());\n    }\n  }\n\n  /**\n   * スコアを加算する\n   * @param {number} lines - 消したライン数\n   */\n  addScore(lines) {\n    if (lines < 1 || lines > 4) return 0;\n    \n    const linePoints = [0, 100, 300, 500, 800];\n    const points = linePoints[lines] * this.level;\n    this.score += points;\n    \n    // レベルアップのチェック\n    const newLines = this.lines + lines;\n    const newLevel = Math.floor(newLines / 10) + 1;\n    const levelUp = newLevel > this.level;\n    \n    this.lines = newLines;\n    if (levelUp) {\n      this.level = newLevel;\n    }\n    \n    return points;\n  }\n\n  /**\n   * ゲームの状態をリセットする\n   */\n  reset() {\n    this.state = GAME_STATE.READY;\n    this.score = 0;\n    this.lines = 0;\n    this.level = 1;\n    this.startTime = null;\n    this.elapsedTime = 0;\n    this.lastUpdateTime = null;\n  }\n\n  /**\n   * 現在のゲーム状態を取得する\n   * @return {Object} ゲーム状態のスナップショット\n   */\n  getState() {\n    return {\n      state: this.state,\n      score: this.score,\n      lines: this.lines,\n      level: this.level,\n      highScore: this.highScore,\n      elapsedTime: this.getElapsedTime(),\n    };\n  }\n\n  /**\n   * 経過時間をフォーマットして返す\n   * @return {string} フォーマットされた時間 (MM:SS)\n   */\n  getElapsedTime() {\n    const totalSeconds = Math.floor((this.elapsedTime + \n      (this.state === GAME_STATE.PLAYING ? Date.now() - this.lastUpdateTime : 0)) / 1000);\n    const minutes = Math.floor(totalSeconds / 60);\n    const seconds = totalSeconds % 60;\n    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n  }\n}\n\nexport default GameState;\n"],"names":["_game","require","_helpers","_Board","_interopRequireDefault","_Tetromino","_GameState","e","__esModule","default","exports","constructor","canvas","onUpdate","onGameOver","Error","this","ctx","getContext","state","GameState","board","Board","COLS","ROWS","currentPiece","nextPiece","ghostPiece","isPressingDown","dropStart","lastDropTime","lastMoveTime","moveDelay","autoRepeatDelay","lastMoveDirection","isAutoRepeating","animationFrameId","setCanvasSize","setupEventListeners","init","reset","spawnPiece","update","notifyUpdate","blockSize","Math","floor","offsetWidth","width","height","style","dpr","window","devicePixelRatio","scale","Tetromino","setPosition","x","y","updateGhostPiece","checkCollision","gameOver","clone","move","piece","offset","testPiece","isValidPosition","timestamp","getState","GAME_STATE","PLAYING","getDropInterval","moveDown","draw","requestAnimationFrame","ts","level","speed","LEVEL_SPEED","min","Object","keys","length","max","clearRect","drawBoard","drawPiece","drawGrid","grid","drawBlock","alpha","getBlocks","forEach","block","color","size","padding","fillStyle","globalAlpha","fillRect","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","moveLeft","performance","now","moveRight","lockPiece","rotate","originalRotation","rotation","kicks","kick","rotateCounterClockwise","hardDrop","dropDistance","linesCleared","lock","addScore","calculateLevel","lines","LINES_PER_LEVEL","start","pause","cancelAnimationFrame","document","addEventListener","handleKeyDown","bind","handleKeyUp","isMobileDevice","setupTouchControls","handleResize","event","key","KEY","LEFT","autoRepeatTimeout","setTimeout","autoRepeatInterval","setInterval","RIGHT","DOWN","UP","includes","preventDefault","clearTimeout","clearInterval","touchStartX","touchStartY","touchStartTime","touch","touches","clientX","clientY","Date","longPressTimer","passive","changedTouches","deltaX","deltaY","abs","destroy","removeEventListener","type","position","random","TETROMINOS","matrix","deepCopyMatrix","COLORS","rotateMatrix","i","delta","undefined","blocks","push","left","right","top","bottom","createRandom","map","row","_","n","result","Array","fill","j","arePositionsEqual","pos1","pos2","getRandomInt","ms","Promise","resolve","calculateScore","currentScore","linesPerLevel","calculateGameSpeed","speedTable","test","navigator","userAgent","rect","target","getBoundingClientRect","cols","rows","createEmptyGrid","clearedLines","tetromino","pos","boardX","boardY","clearLines","isLineComplete","removeLine","splice","unshift","clear","print","console","log","line","SPACE","P","R","READY","PAUSED","GAME_OVER","_Tetris","game","getElementById","startButton","pauseButton","restartButton","scoreElement","levelElement","linesElement","highScoreElement","nextPieceCanvas","gameOverElement","onGameUpdate","textContent","score","highScore","parseInt","localStorage","getItem","setItem","toString","display","disabled","initGame","Tetris","resizeCanvas","container","parentElement","clientWidth","innerHeight","render","resume","gameState","body","startTime","elapsedTime","lastUpdateTime","updateElapsedTime","updateHighScore","points","newLines","newLevel","levelUp","getElapsedTime","totalSeconds","seconds","padStart"],"sourceRoot":""}